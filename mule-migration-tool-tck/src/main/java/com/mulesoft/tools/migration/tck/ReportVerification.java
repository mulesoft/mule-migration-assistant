/*
 * Copyright (c) 2017 MuleSoft, Inc. This software is protected under international
 * copyright law. All use of this software is subject to MuleSoft's Master Subscription
 * Agreement (or other master license agreement) separately entered into in writing between
 * you and MuleSoft. If such an agreement is not in place, you may not use the software.
 */
package com.mulesoft.tools.migration.tck;

import static java.lang.System.lineSeparator;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.nullValue;
import static org.junit.Assert.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;

import com.mulesoft.tools.migration.step.category.MigrationReport;
import com.mulesoft.tools.migration.step.category.MigrationReport.Level;

import org.jdom2.Element;
import org.junit.rules.ExternalResource;
import org.mockito.stubbing.Answer;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

/**
 * Provides a verification to be performed after each test on the report entries generated by a migration.
 * <p>
 * Usage:
 *
 * <pre>
 * 
 * &#64;Rule
 * public ReportVerification report = new ReportVerification();
 * </pre>
 *
 * @author Mulesoft Inc.
 * @since 0.3
 */
public class ReportVerification extends ExternalResource {

  private MigrationReport report;
  private List<ReportEntryElementWithStack> reportedElements = new ArrayList<>();

  @Override
  protected void before() throws Throwable {
    super.before();

    report = mock(MigrationReport.class);
    Answer<Void> elementRegisterAnswer = inv -> {
      Element elementToComment = inv.getArgumentAt(2, Element.class);

      assertThat(elementToComment, not(nullValue()));
      reportedElements.add(new ReportEntryElementWithStack(elementToComment, new Exception()));

      return null;
    };
    doAnswer(elementRegisterAnswer).when(report).report(anyString(), any(Element.class), any(Element.class), anyVararg());
    doAnswer(elementRegisterAnswer).when(report).report(any(Level.class), any(Element.class), any(Element.class), anyString(),
                                                        anyVararg());
  }

  @Override
  protected void after() {
    for (ReportEntryElementWithStack reportEntryElementWithStack : reportedElements) {
      StringWriter writer = new StringWriter();
      reportEntryElementWithStack.stackTraceContainer.printStackTrace(new PrintWriter(writer));
      assertThat(reportEntryElementWithStack.elementToComment.toString() + lineSeparator() + writer.toString(),
                 reportEntryElementWithStack.elementToComment.getDocument(), not(nullValue()));
    }

    super.after();
  }

  public MigrationReport getReport() {
    return report;
  }

  private static class ReportEntryElementWithStack {

    private Element elementToComment;
    private Throwable stackTraceContainer;

    public ReportEntryElementWithStack(Element elementToComment, Throwable stackTraceContainer) {
      this.elementToComment = elementToComment;
      this.stackTraceContainer = stackTraceContainer;
    }

  }
}
